<h1>Huffman Code</h1>

<a href="https://www.codingame.com/training/medium/huffman-code">https://www.codingame.com/training/medium/huffman-code</a>

<div class="statement-body">
<div class="statement-section statement-goal">
   <h2><span class="icon icon-goal">&nbsp;</span><span>Goal </span></h2>
   <span class="question-statement"><strong>Huffman Coding</strong> is an algorithm for doing data compression and it forms the basic idea behind file compression. Instead of allowing every character to occupy 8 bits in a file, we use <strong>variable-length encoding</strong> to assign each symbol a unique binary code according to the frequency of the character in the file, without any ambiguities.<br><br><strong>To put this into perspective:</strong> Suppose a file contains a string &ldquo;aabacdeade&rdquo;, where frequency of characters <var>a</var>, <var>b</var>, <var>c</var>, <var>d</var> and <var>e</var> is 4, 1, 1, 2 and 2 respectively. We assign binary codes to each character as follows: <br><pre style="font-family: monospace">a --&gt; 00	  b --&gt; 010	  c --&gt; 011	  d--&gt; 10	  e--&gt; 11 </pre><br>The process of encoding can be divided into two parts:<br><br><strong>Part 1: Building a Huffman tree</strong><br>First, assume all of the characters as individual trees with frequency as their weight. Now, we use a greedy approach to find the two trees with the smallest weights. Then, join them to create a new tree with the sum of those two as its weight and repeat this process until we have a single tree remaining.<br><br>For the above example:<br><pre style="font-family: monospace"></pre><pre style="font-family: monospace"><br>Step 1:   [a] [d] [e]    #      --&gt; Here: a = 4, d = 2, e = 2, (bc) = 2<br>                        / \<br>                      [b] [c]<br><br>Step 2:   [a]    #          #      --&gt; Here: a = 4, (bc) = 2, (de) = 4<br>                / \        / \<br>              [b] [c]    [d] [e]<br><br>Step 3:       #            #      --&gt; Here: (de) = 4, (a(bc)) = 6<br>             / \          / \<br>           [a]  #       [d] [e]<br>               / \<br>             [b] [c]<br><br>Step 4:        #             --&gt; Here: ((de)(a(bc))) = 10<br>              / \   <br>             /   \  <br>            /     \   <br>           #       #  <br>          / \     / \<br>       [a]   #  [d] [e]<br>            / \<br>          [b] [c]<br><br></pre><pre style="font-family: monospace"></pre><br><strong>Part 2: Assigning binary codes to each symbol by traversing Huffman tree</strong><br>Generally, bit &lsquo;0&rsquo; represents the left child and bit &lsquo;1&rsquo; <br>represents the right child<br><pre style="font-family: monospace"></pre><pre style="font-family: monospace"><br>                   #                          <br>                0 / \ 1  <br>                 /   \  <br>                /     \<br>               /       \<br>              #         #<br>           0 / \ 1   0 / \ 1<br>            /   \     /   \<br>         [a]     #  [d]   [e]<br>              0 / \ 1<br>               /   \<br>             [b]   [c]<br></pre><pre style="font-family: monospace"></pre><br>Thus by going through the tree, we will come up with <br><pre style="font-family: monospace">a = 00, b = 010, c = 011, d = 10, e = 11</pre><br><br><strong>Test Case 1</strong> <br>n = 5<br>frequencies = 4 1 1 2 2<br>bit length for each test case in order = 2 3 3 2 2 [see above for clarification]<br>total bit count = 4 * 2 + 1 * 3 + 1* 3 + 2 * 2 + 2 * 2   = 22<br><br><strong>0utput :</strong> 22<br><br><br><br><strong>Here are some links to understand it further :</strong><br>https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/<br>https://www.studytonight.com/data-structures/huffman-coding</span>
</div>
<div class="statement-section statement-protocol">
   <div class="blk">
      <div class="title">Input</div>
      <div class="question-statement-input"><strong>Line 1:</strong> A single integer <var>N</var> representing the number of characters<br><strong>Line 2:</strong> An ordered sequence of <var>frequency</var> values separated by space, where <br>1 2 3 ... N represents char1 = 1, char2 = 2, char3 = 3 ... charN = N</div>
   </div>
   <div class="blk">
      <div class="title">Output</div>
      <div class="question-statement-output">A single value representing the <strong>least number of bits</strong> used to store the complete file.</div>
   </div>
   <div class="blk">
      <div class="title">Constraints</div>
      <div class="question-statement-constraints">1 &le; <var>N</var> &le; 3000</div>
   </div>
   <div class="blk">
      <div class="title">Example</div>
      <div class="statement-inout">
         <div class="statement-inout-in">
            <div class="title">Input</div>
            <pre class="question-statement-example-in">5
4 1 1 2 2</pre>
         </div>
         <div class="statement-inout-out">
            <div class="title">Output</div>
            <pre class="question-statement-example-out">22</pre>
         </div>
      </div>
   </div>
</div>